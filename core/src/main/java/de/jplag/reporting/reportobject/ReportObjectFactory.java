package de.jplag.reporting.reportobject;

import static de.jplag.reporting.reportobject.mapper.SubmissionNameToIdMapper.buildSubmissionNameToIdMap;

import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.jplag.JPlag;
import de.jplag.JPlagComparison;
import de.jplag.JPlagResult;
import de.jplag.Language;
import de.jplag.Submission;
import de.jplag.options.JPlagOptions;
import de.jplag.reporting.FilePathUtil;
import de.jplag.reporting.jsonfactory.BaseCodeReportWriter;
import de.jplag.reporting.jsonfactory.ComparisonReportWriter;
import de.jplag.reporting.reportobject.mapper.ClusteringResultMapper;
import de.jplag.reporting.reportobject.mapper.MetricMapper;
import de.jplag.reporting.reportobject.model.Cluster;
import de.jplag.reporting.reportobject.model.FailedSubmission;
import de.jplag.reporting.reportobject.model.RunInformation;
import de.jplag.reporting.reportobject.model.SubmissionFile;
import de.jplag.reporting.reportobject.model.SubmissionFileIndex;
import de.jplag.reporting.reportobject.model.SubmissionMappings;
import de.jplag.reporting.reportobject.model.TopComparison;
import de.jplag.reporting.reportobject.model.Version;
import de.jplag.reporting.reportobject.writer.JPlagResultWriter;
import de.jplag.reporting.reportobject.writer.ZipWriter;

/**
 * Factory class, responsible for converting a JPlagResult object to Overview and Comparison DTO classes and writing it
 * to the disk.
 */
public class ReportObjectFactory {
    private static final Logger logger = LoggerFactory.getLogger(ReportObjectFactory.class);

    private static final Path DISTRIBUTION_FILE_NAME = Path.of("distribution.json");
    private static final Path RUN_INFORMATION_FILE_NAME = Path.of("runInformation.json");
    private static final Path TOP_COMPARISONS_FILE_NAME = Path.of("topComparisons.json");
    private static final Path CLUSTER_FILE_NAME = Path.of("cluster.json");
    private static final Path SUBMISSION_MAPPINGS_FILE_NAME = Path.of("submissionMappings.json");
    private static final Path README_FILE_NAME = Path.of("README.txt");
    private static final Path OPTIONS_FILE_NAME = Path.of("options.json");
    private static final String[] README_CONTENT = new String[] {"This is a software plagiarism report generated by JPlag.",
            "To view the report first get the newest version of JPlag from https://github.com/jplag/JPlag/releases/latest.",
            "Start the jar using 'java -jar jarname'. This opens a locally hosted website where you can drag this report onto the page."};

    private static final Path SUBMISSION_FILE_INDEX_FILE_NAME = Path.of("submissionFileIndex.json");
    /** Version of the report viewer. **/
    public static final Version REPORT_VIEWER_VERSION = JPlag.JPLAG_VERSION;
    private static final Path SUBMISSIONS_ROOT_PATH = Path.of("files");

    private Map<String, String> submissionNameToIdMap;
    private Function<Submission, String> submissionToIdFunction;
    private Map<String, Map<String, String>> submissionNameToNameToComparisonFileName;

    private final JPlagResultWriter resultWriter;

    /**
     * Creates a new report object factory, that can be used to write a report.
     * @param resultWriter The writer to use for writing report content
     */
    public ReportObjectFactory(JPlagResultWriter resultWriter) {
        this.resultWriter = resultWriter;
    }

    /**
     * Creates a new report object factory, that can be used to write a report file.
     * @param targetFile The file to write the report to.
     * @throws FileNotFoundException If the file cannot be opened for writing
     */
    public ReportObjectFactory(File targetFile) throws FileNotFoundException {
        this(new ZipWriter(targetFile));
    }

    /**
     * Creates all necessary report viewer files, writes them to the disk as ZIP file with a <code>.jplag</code> extension.
     * @param result The JPlagResult to be converted into a report.
     */
    public void createAndSaveReport(JPlagResult result) {
        logger.info("Start writing report...");
        buildSubmissionToIdMap(result);

        copySubmissionFilesToReport(result);

        writeComparisons(result);

        writeRunInformation(result);
        writeDistribution(result);
        writeTopComparisons(result);
        writeCluster(result);
        writeSubmissionMappings();

        writeSubmissionIndexFile(result);
        writeReadMeFile();
        writeOptionsFiles(result.getOptions());
        writeBaseCodeReport(result);

        this.resultWriter.close();
    }

    private void buildSubmissionToIdMap(JPlagResult result) {
        submissionNameToIdMap = buildSubmissionNameToIdMap(result);
        submissionToIdFunction = (Submission submission) -> submissionNameToIdMap.get(submission.getName());
    }

    private void copySubmissionFilesToReport(JPlagResult result) {
        logger.info("Start to export results...");
        List<JPlagComparison> comparisons = result.getComparisons(result.getOptions().maximumNumberOfComparisons());
        Set<Submission> submissions = getSubmissions(comparisons);
        Language language = result.getOptions().language();
        for (Submission submission : submissions) {
            for (File file : submission.getFiles()) {
                Path filePath = FilePathUtil.getRelativeSubmissionPath(file, submission, submissionToIdFunction);
                Path resultPath = SUBMISSIONS_ROOT_PATH.resolve(filePath);

                File fileToCopy = getFileToCopy(language, file);
                this.resultWriter.addFileContentEntry(resultPath, fileToCopy);
            }
        }
    }

    private File getFileToCopy(Language language, File file) {
        return language.useViewFiles() ? new File(file.getPath() + language.viewFileExtension()) : file;
    }

    private void writeComparisons(JPlagResult result) {
        ComparisonReportWriter comparisonReportWriter = new ComparisonReportWriter(submissionToIdFunction, this.resultWriter);
        submissionNameToNameToComparisonFileName = comparisonReportWriter.writeComparisonReports(result);
    }

    private void writeBaseCodeReport(JPlagResult result) {
        BaseCodeReportWriter baseCodeReportWriter = new BaseCodeReportWriter(submissionToIdFunction, this.resultWriter);
        baseCodeReportWriter.writeBaseCodeReport(result);
    }

    private void writeRunInformation(JPlagResult result) {
        List<FailedSubmission> failedSubmissions = result.getSubmissions().getInvalidSubmissions().stream()
                .map(submission -> new FailedSubmission(submission.getName(), submission.getState())).toList();
        RunInformation runInformation = new RunInformation(REPORT_VIEWER_VERSION, failedSubmissions, getDate(), result.getDuration(),
                result.getAllComparisons().size());
        this.resultWriter.addJsonEntry(runInformation, RUN_INFORMATION_FILE_NAME);
    }

    private void writeDistribution(JPlagResult result) {
        Map<String, List<Integer>> distributions = MetricMapper.getDistributions(result);
        this.resultWriter.addJsonEntry(distributions, DISTRIBUTION_FILE_NAME);
    }

    private void writeTopComparisons(JPlagResult result) {
        List<TopComparison> topComparison = new MetricMapper(submissionToIdFunction).getTopComparisons(result);
        this.resultWriter.addJsonEntry(topComparison, TOP_COMPARISONS_FILE_NAME);
    }

    private void writeCluster(JPlagResult result) {
        List<Cluster> cluster = new ClusteringResultMapper(submissionToIdFunction).map(result);
        this.resultWriter.addJsonEntry(cluster, CLUSTER_FILE_NAME);
    }

    private void writeSubmissionMappings() {
        SubmissionMappings mappings = new SubmissionMappings(
                submissionNameToIdMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)),
                submissionNameToNameToComparisonFileName);
        this.resultWriter.addJsonEntry(mappings, SUBMISSION_MAPPINGS_FILE_NAME);
    }

    private void writeReadMeFile() {
        this.resultWriter.writeStringEntry(String.join(System.lineSeparator(), README_CONTENT), README_FILE_NAME);
    }

    private void writeSubmissionIndexFile(JPlagResult result) {
        List<JPlagComparison> comparisons = result.getComparisons(result.getOptions().maximumNumberOfComparisons());
        Set<Submission> submissions = getSubmissions(comparisons);
        SubmissionFileIndex fileIndex = new SubmissionFileIndex(new HashMap<>());

        List<Map<String, Map<String, SubmissionFile>>> submissionTokenCountList = submissions.stream().parallel().map(submission -> {
            Map<String, SubmissionFile> tokenCounts = new HashMap<>();
            for (Map.Entry<File, Integer> entry : submission.getTokenCountPerFile().entrySet()) {
                String key = FilePathUtil.getRelativeSubmissionPath(entry.getKey(), submission, submissionToIdFunction).toString();
                tokenCounts.put(key, new SubmissionFile(entry.getValue()));
            }
            return Map.of(submissionNameToIdMap.get(submission.getName()), tokenCounts);
        }).toList();

        submissionTokenCountList.forEach(submission -> fileIndex.fileIndexes().putAll(submission));
        this.resultWriter.addJsonEntry(fileIndex, SUBMISSION_FILE_INDEX_FILE_NAME);
    }

    private void writeOptionsFiles(JPlagOptions options) {
        resultWriter.addJsonEntry(options, OPTIONS_FILE_NAME);
    }

    private Set<Submission> getSubmissions(List<JPlagComparison> comparisons) {
        Set<Submission> submissions = comparisons.stream().map(JPlagComparison::firstSubmission).collect(Collectors.toSet());
        Set<Submission> secondSubmissions = comparisons.stream().map(JPlagComparison::secondSubmission).collect(Collectors.toSet());
        submissions.addAll(secondSubmissions);
        return submissions;
    }

    private String getDate() {
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
        Date date = new Date();
        return dateFormat.format(date);
    }
}
