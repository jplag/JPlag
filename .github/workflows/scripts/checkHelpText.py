'''
This script extracts all help text parameter descriptions from the documentation and compares it to the help text generated by the jar file.
Steps:
1) Get content of files that should contain the help text (mentioned in variable filesToCheck).
2) Extract all triple fenced code blocks from the file content. (```)
3) Find the code block that starts with "Parameter descriptions:". This is the one that contains the CLI text.
4) Remove empty lines at the end of the code block, as this can mess up the comparison.
5) Get the help text from the jar file using the command "java -jar jplag.jar -h".
6) Compare the CLI text from the jar with the one in the documentation. If they do not match, add an error to the list of errors.
7) Print the errors found, if any. If no errors are found, print "No errors found." and exit with code 0.

Important: This script relies on the help text being inside a tripple fe4nced code block (```) starting with "Parameter descriptions:". If this ever changes this script will fail.
'''
import subprocess

# Extract all triple fenced blocks from the text and returns them without the ```
# Each section is a list of lines, and the list of sections is a list of lists
def getAllCodeSections(text):
    codeSections = []
    currentSection = None

    for line in text:
        if line.startswith("```"):
            if currentSection is not None:
                codeSections.append(currentSection)
                currentSection = None
            else:
                currentSection = []
        else:
            if currentSection is not None:
                currentSection.append(line)

    if currentSection is not None:
        codeSections.append(currentSection)

    return codeSections

# Reads a file as a list of lines
def getFilesText(file):
    f = open(file, 'r', encoding='utf-8')
    return f.read().split('\n')

# Filters the sections to find the one that starts with "Parameter descriptions:", which is the one indicating the CLI text
def getCliTextCodeSection(sections):
    for section in sections:
        if section[0].startswith("Parameter descriptions:"):
            return section
    return None

# Removes empty lines at the end of the list
def removeEmptyLinesAtEndOfDocument(text):
    while len(text) > 0 and text[-1].strip() == "":
        text.pop()
    return text

# Stores the offset of the CLI text in the original file
lineOffset = {}

# Reads the file and extracts the CLI text from it
def getCliTextFromFile(file):
    text = getFilesText(file)
    codeSections = getAllCodeSections(text)
    cliTextSection = getCliTextCodeSection(codeSections)
    if cliTextSection is None:
        return None
    removedEmptyLines = removeEmptyLinesAtEndOfDocument(cliTextSection)
    lineOffset[file] = text.index(cliTextSection[0]) + 1 if cliTextSection else 0
    return removedEmptyLines

class Error:
    def __init__(self, fileName, lineNumber, message):
        self.fileName = fileName
        self.lineNumber = lineNumber
        self.message = message

    def __str__(self):
        offset = lineOffset[self.fileName] if self.fileName in lineOffset else 0
        return f"{self.fileName.split('/')[-1]}:{self.lineNumber+offset}: {self.message}"

errors = []

# get help text from jar, the first 5 lines get removed as they are not part of the help text in our markdown documents
helpTextLines = subprocess.run(["java", "-jar", "jplag.jar", "-h"], capture_output=True, text=True).stdout.split('\n')[5::]
helpTextLines = removeEmptyLinesAtEndOfDocument(helpTextLines)

# these are the files that contain the help text
filesToCheck = ["../../../README.md", "../../../docs/1.-How-to-Use-JPlag.md"]

# Verifies that the CLI text from the jar matches the one in the md file
def checkCliTextAgainstHelpText(mdText, fileName):
    minLines = min(len(mdText), len(helpTextLines))
    if (len(mdText) != len(helpTextLines)):
        errors.append(Error(fileName, minLines, f"The number of lines in the CLI text from the jar({len(helpTextLines)}) does not match the md text({len(mdText)})."))
    for i in range(minLines):
        if (mdText[i] != helpTextLines[i]):
            helpSpace = helpTextLines[i].replace(" ", '\u23B5')
            mdSpace = mdText[i].replace(" ", '\u23B5')
            errors.append(Error(fileName, i, f"Does not match the CLI text from the jar. Expected: '{helpSpace}', Found: '{mdSpace}'."))

for file in filesToCheck:
    cliText = getCliTextFromFile(file)

    if cliText is None:
        errors.append(Error(file, 0, "No CLI text found in the file."))
    else:
        checkCliTextAgainstHelpText(cliText, file)

if len(errors) > 0:
    print("Errors found:")
    for error in errors:
        print(error)
    exit(1)
else:
    print("No errors found.")
    exit(0)
